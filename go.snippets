global !p

from snippets import *
from snippets.go import *

import px.snippets

import px.whitespaces
endglobal

context "is_if_condition(snip)"
snippet e "" w
${1:${VISUAL}} == "$2"
endsnippet

context "is_if_condition(snip)"
snippet en "" w
${1:${VISUAL}} != "$2"
endsnippet

context "is_if_condition(snip)"
snippet l "" w
len(${1:${VISUAL}}) == ${2:0}
endsnippet

context "is_if_condition(snip)"
snippet ln "" w
len(${1:${VISUAL}}) != ${2:0}
endsnippet

priority 2
snippet e "" wb
err := ``
endsnippet

priority 2
context "not is_string()""
snippet = "" wbA
${1:err} := ``
endsnippet

global !p
def insert_space(snip, space=" "):
    line = snip.buffer[snip.line]
    if snip.buffer[snip.line] != snip.context:
        line = snip.context

    snip.buffer[snip.line] = \
        line[:snip.column] + \
        space + \
        line[snip.column:]

    snip.cursor.set(
        snip.line,
        snip.column + len(space),
    )
endglobal

priority 3
# preserving original line 'and snip.buffer[snip.line]' to prevent
# ) deletion by matchem
context "not is_string() and snip.buffer[snip.line]"
post_jump "insert_space(snip)"
snippet , "comma auto" eAi
,X
endsnippet

snippet n "func anonymous" b
func ($1) $2${2/.+/ /}{
	$3
}
endsnippet

snippet "^n" "" "not is_string()" bweAr
func $1($2) $3${3/.+/ /}{
	$4
}

endsnippet

priority 10
context "not is_string() and should_expand_case(snip.buffer, snip.line)"
snippet c "switch case" bweA
case $1:
	$2
$3
endsnippet

priority 10
context "not is_string() and should_expand_case(snip.buffer, snip.line)"
snippet d "switch default" bweA
default:
    $1
endsnippet

priority 10
context "not is_string() and should_expand_fallthrough(snip.buffer, snip.line)"
snippet f "switch fallthrough" bweA
fallthrough
endsnippet


context "not is_string() and is_before_first_func(snip)"
priority 10
snippet "^s$" "type struct auto" bwreA
`!p
if re.match("^([\w\[\]{}]+)$", t[2]):
        type_left = " "
        type_right = ""
else:
        type_left = " struct {\n\t"
        type_right = "\n}"
        if re.match("^\w+\(\)", t[2]):
                type_left = " interface {\n\t"
`type $1`!p snip.rv=type_left`$2`!p snip.rv=type_right`
$0
endsnippet

context "is_first_line(snip)"
priority 1000
snippet p "" bweA
package ${1:`!p snip.rv=guess_package_from_file_name(snip.fn)`}

$0
endsnippet

context "is_first_line(snip)"
priority 2
snippet "package m" "" bwrAe
package main
endsnippet

context "snip.line == 0 and snip.column == 0"
snippet m "" eA
package main

func main() {
	$0
}
endsnippet


context "is_if_body(snip)"
snippet lf "" bweA
log.Fatal(err)
endsnippet

context "is_for_body(snip)""
snippet c "continue in if" eb
continue
endsnippet

priority -1
context "px.snippets.make_context(snip)"
pre_expand "px.common.get_active_completer().reset()"
post_jump "jump_to_if_body_on_err_not_nil(snip)"
snippet i "if" bw
if ${1:`!p snip.rv=get_value_for_if(snip.c, snip.context)`} {
    ${2:${VISUAL}}
}
endsnippet

context "not is_string() and is_type_decl(snip)"
snippet "[sife]" "" wer
`!p
if match.group(0) == 's':
	typeName = 'string'
if match.group(0) == 'i':
	typeName = 'int'
if match.group(0) == 'f':
	typeName = 'float64'
if match.group(0) == 'e':
	typeName = 'error'
`$1 `!p snip.rv = typeName`
endsnippet

context "not is_string() and is_func_decl(snip)"
snippet "((?<!,)\s)?([sife])" "" wer
`!p
if match.group(2) == 's':
	typeName = 'string'
if match.group(2) == 'i':
	typeName = 'int'
if match.group(2) == 'f':
	typeName = 'float64'
if match.group(2) == 'e':
	typeName = 'error'
if match.group(1):
	snip.rv = ', '

commaAfter = ''
if t[2] == ' ':
	commaAfter = ','
elif t[2] == ',':
	t[2] = ', '
elif t[2].startswith(', '):
	commaAfter = ''
elif t[2] != '':
	commaAfter = ', '

`$1 `!p snip.rv = typeName + commaAfter`$2
endsnippet

context "not is_string() and is_type_decl(snip)"
snippet "t" "anon struct" wer
 struct {
    $1
}
endsnippet

context "not is_string() and is_type_decl(snip)"
snippet m "" bwe
$1 map[${2:string}]${3:interface{}}
endsnippet

context "not is_string() and is_func_decl(snip)"
snippet m "" we
$1 map[${2:string}]${3:interface{}}${4/.+/(?0:, )/}$4
endsnippet

priority -1
snippet ii "if <VISUAL>" bwA
if ${VISUAL} {
	$1
}
endsnippet

snippet fe "fmt.Errorf($1 or VISUAL)" w
fmt.Errorf(${1:${VISUAL}})
endsnippet

snippet fef "fmt.Errorf with message" w
fmt.Errorf("$1: %s", ${2:${VISUAL:err}})
endsnippet

snippet ff "fmt.Errorf only message" w
fmt.Errorf("$1")
endsnippet

snippet r "return" bw
return $1
endsnippet

context "is_if_body(snip)"
snippet r "" eb
return ${1:err}
endsnippet

snippet ,e ", err" iA
, err$0
endsnippet

context "px.langs.go.is_if_bracket(snip.buffer, snip.line, snip.column-1)"
snippet "}([\w])" "else before closing bracket" bwrA
} else {
	`!p snip.rv=match.group(1)`$1
}
endsnippet

context "px.langs.go.is_if_bracket(snip.buffer, snip.line, snip.column-1)"
priority 2
snippet "} " "else before closing bracket" bwrA
} else {
    $1
}
endsnippet

context "not is_string() and is_before_first_func(snip)"
snippet "^c$" "" bwreA
const (
	$0
)
endsnippet

snippet ass "anon struct with fields" w
struct {
	$1
}{
	$2
}
endsnippet

snippet "((\w+)\s*([\w\[\]]+)) to$" "toml annotation" "not px.syntax.is_string(snip.cursor)" bre
`!p snip.rv=match.group(1)` \`toml:"`!p
snip.rv=px.util.convert_camelcase_to_snakecase(match.group(2))`"\`
endsnippet

snippet "((\w+)\s*([\w\[\]]+)) js$" "json annotation"  "not px.syntax.is_string(snip.cursor)" bre
`!p snip.rv=match.group(1)` \`json:"`!p
snip.rv=px.util.convert_camelcase_to_snakecase(match.group(2))`"\`
endsnippet

snippet "((\w+)\s+([\w\[\]]+)) sc$" "schema annotation"  "not px.syntax.is_string(snip.cursor)" bre
`!p snip.rv=match.group(1)` \`schema:"`!p
snip.rv=px.util.convert_camelcase_to_snakecase(match.group(2))`"\`
endsnippet

snippet msi "map[string]interface" w
map[string]interface{}
endsnippet

snippet s "switch" bw
switch ${1:name} {
case ${2:true}:
	$3
$4
}
endsnippet

snippet w "switch true" bw
switch {
case ${1}:
	$2
$3
}
endsnippet

snippet se "select" bw
select {
case ${1}:
	$2
$3
}
endsnippet

snippet pe "fmt.Printf(%#v" bw
fmt.Println("XXXXXX `!p snip.rv=os.path.basename(px.buffer.get().name)+":"+str(px.cursor.get()[0])`")
endsnippet

snippet pr "fmt.Printf(%#v" bw
`!p
left=t[1] + ': %#v\\n", '
right=')'
if " " in t[1]:
	left=''
	right='\\n")'

left = " "+os.path.basename(px.buffer.get().name)+":"+str(px.cursor.get()[0])+": "+left
`fmt.Printf("XXXXXX`!p snip.rv=left`$1`!p snip.rv=right`
endsnippet

snippet play "package main" bw
package main

import "fmt"

func main() {
	$0
}
endsnippet

post_jump "px.snippets.expand(snip)"
snippet "^v" "var" bwrA
vr$1
endsnippet

post_jump "px.snippets.expand(snip)"
snippet "v" "var" bwr
vr$1
endsnippet

snippet "vr" "var" bwr
`!p
vis = "// variables"
if snip.v.text  != "":
	vis = snip.v.text.replace(" := ", " = ")
`
var (
	${1:`!p snip.rv=vis`}
)
endsnippet

snippet rn "return nil" bw
return nil
endsnippet

snippet ap "append" bw
${1:slice} = append($1, $2)
endsnippet

snippet ms "make slice" w
make([]$1, ${2:0})
endsnippet

snippet mc "make chan" w
make(chan $1, ${2:0})
endsnippet

snippet mm "make map" w
make(map[${1:string}]${2:interface\{\}})
endsnippet

snippet if "interface" w
interface{}
endsnippet

snippet ts "type switch" bw
switch ${1:newVar} := ${2:checkVar}.(type) {
case ${3:Type}:
	$4
}
endsnippet

priority 5
context "not is_string()"
snippet ", n" ", nil"  ie
, nil
endsnippet

priority 5
context "not is_string()"
snippet  ", e" "err, " ie
, err``
endsnippet

priority 5
context "not is_string()"
snippet  n, "nil, " Ae
nil, ``
endsnippet

priority 5
context "not is_string()"
snippet  e, "err, " Ae
err, ``
endsnippet

snippet "return e" "return err" bw
return err
endsnippet

global !p


def get_indent_levels(snip, base_line):
    if snip.context is None:
        snip.context = {}

    if len(snip.buffer) <= base_line+1:
        return

    snip.context['upper_indent'] = px.whitespaces.get_indentation(
        snip.buffer[base_line]
    )[1]

    snip.context['inner_indent'] = px.whitespaces.get_indentation(
        snip.buffer[base_line+1]
    )[1]

    return snip.context
endglobal

context "get_indent_levels(snip, snip.line)"
post_expand "get_indent_levels(snip, snip.snippet_start[0])"
snippet "return(.*)h" "return hierr" bwr
return`!p snip.rv = match.group(1)`hierr.Errorf(
    err,
    \`$1\``!p

snip.rv = (",\n" + snip.context['inner_indent'] if t[2] else ",")

`$2`!p

snip.rv = ("," if t[2] else "") + "\n" + snip.context['upper_indent'] + ")"

`
endsnippet

post_jump "px.snippets.expand(snip)"
snippet rh "" b
return h$1
endsnippet

snippet "return n" "return nil" bw
return nil
endsnippet

snippet "r (.)" "return auto" bwrA
return `!p snip.rv=match.group(1)`
endsnippet

snippet frr "forever" bw
for {
	$1
}
endsnippet

snippet qt "t.fatal" bw
if err != nil {
	t.Fatal(err)
}
endsnippet

snippet tf "t.fatalf" bw
t.Fatalf("$1")
endsnippet

snippet qf "log fatal" bw
if err != nil {
	log.Fatal(err)
}
endsnippet

snippet qff "log fatalf" bw
if err != nil {
	log.Fatalf(\`$1: %s\`, $2, err)
}
endsnippet

snippet rt "return true" bw
return true
endsnippet

snippet fa "false" w
false
endsnippet

snippet tr "false" w
true
endsnippet

snippet rf "return false" bw
return false
endsnippet

context "not is_string() and px.langs.go.extract_prev_method_binding(snip.buffer, snip.cursor) and {'line': snip.line}"
snippet "^d$" "" bweAr
`!p
(a_left, a_right, r_left, r_right, binding) = action_define_method(snip.context, t, True)
`
func (`!p snip.rv=binding`) $1`!p snip.rv=a_left`$2`!p snip.rv=a_right``!p snip.rv=r_left`$3`!p snip.rv=r_right`{
	$4
}

endsnippet

snippet re "return errors.New" bw
return errors.New($1)
endsnippet

snippet lf "log.Printf" w
log.Printf($1)
endsnippet

snippet ld "log.Printf error" w
log.Printf("$1: %s", ${2:err})
endsnippet

snippet td "todo" bw
// @TODO:
endsnippet

snippet l "last slice usage" iw
${1:`!p snip.rv=px.langs.go.get_previous_slice_usage()`}[$2]
endsnippet

snippet "(func\s.*\)\s+)([\w\d_\s\{\}\[\]\*\.]+),\s?([\w\d_\s\{\}\[\]\*\.]+)" "add commas around multple return variables" rA
`!p snip.rv=match.group(1)`(`!p snip.rv=match.group(2)`, `!p snip.rv=match.group(3)`$0)
endsnippet

snippet "^\)\s+?([\w\d_\s\{\}\[\]\*\.]+),\s+?([\w\d_\s\{\}\[\]\*\.]+)" "return multipleadd commas around multple return variables" rA
) (`!p snip.rv=match.group(1)`, `!p snip.rv=match.group(2)`$0)
endsnippet

snippet lp "log.Printf" wA
`!p
left = ''
right = ''
if " " in t[1] and not '"' in t[1]:
	left = '"'
	right = '"'

func = "Printf"
if t[1] == "err":
	func = "Println"

`log.`!p snip.rv=func`(`!p snip.rv=left`$1`!p snip.rv=right`)
endsnippet

snippet fp "fmt.Println" wA
fmt.Println($1)
endsnippet

snippet ej "print json" bw
`!p
from random import randint

name = "xxx" + str(randint(10, 9999))
`ej`!p snip.rv=name`, _ := json.MarshalIndent($1, "", "  ")
fmt.Printf("`!p snip.rv=t[1]`: %s\n", string(ej`!p snip.rv=name`))
endsnippet

snippet "^e" "func Test" wrA
func Test$1(t *testing.T) {
	test := assert.New(t)

	$2
}
endsnippet

context "not is_string() and px.langs.go.is_return_argument(snip.buffer, snip.line, snip.column)"
snippet , "return ... , nil" ie
, `!p if px.langs.go.is_in_err_condition(px.buffer.get(), px.cursor.get()[0], px.cursor.get()[1]):
	snip.rv = "err"
else:
	snip.rv = "nil"`
endsnippet

snippet ef "fmt.Errorf" w
fmt.Errorf($1, $2)
endsnippet

snippet tx "this instance" w
`!p
buffer = px.buffer.get()
line, column = px.cursor.get()

result = 't'
while True:
	line = line - 1
	if line == 0:
		break

	line_contents = buffer[line]
	matches = re.match(r'(?m)^func \(([^)]+)\s+([^)]+)\) ', line_contents)
	if not matches:
		continue

	result = matches.group(1)
	break


snip.rv=result`
endsnippet

context "not is_string() and px.langs.go.gocode_can_complete()"
pre_expand "gocode_complete_function(snip)"
snippet "(\w+\.\w+)" "" re
endsnippet

global !p
endglobal

context "should_expand_amp(snip)"
snippet & "expand amp" Awe
&& $0
endsnippet


snippet ", ," "underscore auto" iAr
, _
endsnippet

snippet "^t" "not is_string()" wAre
type (
`!p
snip.rv=snip.v.text.replace("type ", "\t")
`)
endsnippet

snippet err.E "err.Error()" wA
err.Error()
endsnippet

context "not is_string()"
snippet "^o$" "new" rA
`!p

if t[1]:
	type = t[1]
else:
	bindings = px.langs.go.extract_prev_method_binding(
		px.buffer.get(),
		px.cursor.get()
	)
	if not bindings:
		type = 'someStruct'
	else:
		type = bindings[1]

ctype = type[0].upper() + type[1:]
`func New`!p snip.rv=ctype`($2) (${1:`!p snip.rv=type`}, error) {
	$3
}
endsnippet

snippet "^p$" "new" rA
`!p

if t[1]:
	type = t[1]
else:
	bindings = px.langs.go.extract_prev_method_binding(
		px.buffer.get(), px.cursor.get()
	)
	if not bindings:
		type = 'someStruct'
	else:
		type = bindings[1]

ctype = type[0].upper() + type[1:]
`func New`!p snip.rv=ctype`($2) (*${1:`!p snip.rv=type`}, error) {
	$3
}
endsnippet

snippet f "for range" bw
for ${2}, ${3} := range ${1:`!p snip.rv=get_value_for_for(snip.c)`} {
	${4:${VISUAL}}
}
endsnippet

snippet fo "for without body" bw
for {
	${1:${VISUAL}}
}
endsnippet

global !p
def get_padded_equal_sign(selection=None):
	if not selection:
		cursor = px.cursor.get()
		selection = px.buffer.get()[cursor[0]][:cursor[1]]

	if not selection:
		return "="

	if re.match(r'\w', selection[-1]):
		return " = "
	else:
		return "= "
endglobal

priority 10
snippet = "visual equals" "get_selected_placeholder(snip)" iAe
`!p snip.rv = snip.context + get_padded_equal_sign(snip.context)`
endsnippet

priority 10
post_expand "fix_matchem('(')"
snippet ( "visual paren" "get_selected_placeholder(snip)" iAe
$1(`!p snip.rv = snip.context`)
endsnippet

priority 10
snippet ! "visual exclam" "get_selected_placeholder(snip)" iAe
!`!p snip.rv = snip.context`
endsnippet

priority 10
snippet . "visual period dot" "get_selected_placeholder(snip)" iAe
`!p snip.rv = snip.context`.
endsnippet

priority 1
snippet = "visual equals" "snip.visual_text" iAe
`!p snip.rv = snip.context + get_padded_equal_sign(snip.context)`
endsnippet

global !p
def is_inside_brackets(sni):
    line = snip.buffer[snip.line]

    return px.cursor.is_between(line, snip.cursor, '\[', '\]')


def before_equal_sign(snip):
    line = snip.buffer[snip.line]
    if len(line) <= snip.column+1:
        return False

    return line[snip.column+1] == '='


def is_inside_struct_instance(snip):
    return px.whitespaces.match_higher_indent(
        snip.buffer, snip.cursor, '[\w.]+{$'
    )


def is_inside_map(snip):
    return px.whitespaces.match_higher_indent(
        snip.buffer, snip.cursor, 'map\S+{$'
    )

def is_viable_for_equal_statement(snip):
    return not is_string() and \
        not is_inside_brackets(snip) and \
        not before_equal_sign(snip) and \
        not is_inside_struct_instance(snip) and \
        not is_inside_map(snip)
endglobal

context "is_viable_for_equal_statement(snip)"
snippet : "colon equals auto" iAe
 :=`!p snip.rv = ' '`
endsnippet

context "is_inside_struct_instance(snip)"
snippet : "colon space auto" iAe
:`!p snip.rv = ' '`
endsnippet

snippet = "" "not is_string()" iAe
`!p snip.rv = get_padded_equal_sign()`
endsnippet

priority 2
snippet "= =" "" "is_if_condition(snip)" Aie
== $0
endsnippet

priority 2
snippet "= =" "" Ai
:= $0
endsnippet

priority 3
snippet "== =" "" Ai
!= $0
endsnippet

priority 3
snippet "!= =" "" Ai
== $0
endsnippet

priority 3
snippet ":= =" "" Ai
= $0
endsnippet

snippet "=  " "!= nil" "is_if_condition(snip)" Aer
!= nil$0
endsnippet

snippet "= n" "" "is_if_condition(snip)" Aie
= nil$0
endsnippet

priority 4
snippet "== nil[=n]" "" "is_if_condition(snip)" Aier
!= nil$0
endsnippet

priority 4
snippet "!= nil[=n]" "" "is_if_condition(snip)" Aier
== nil$0
endsnippet

########################################################################################

global !p
def get_program_name_from_usage(snip):
	prev_line = snip.buffer[snip.snippet_start[0] - 1]
	return prev_line.strip().split(' ', 1)[0]

def guess_binary_name_from_path():
	return os.path.basename(os.path.realpath('.'))

def add_usage(snip):
	px.langs.go.goto_const();
	snip.expand_anon("""var version = "${2:1.0}"

var usage = \`{PROGRAM} - $1

$3

Usage:
  {PROGRAM} -h | --help
  $4

Options:
  -h --help  Show this help.
  $0
`

""".replace('{PROGRAM}', snip.tabstops[1].current_text), options='m')
endglobal

post_jump "if snip.tabstop == 0: add_usage(snip)"
snippet do "docopt" b
args, err := docopt.Parse(usage, nil, true, "${1:`!p snip.rv = guess_binary_name_from_path()`} " + version, false)
if err != nil {
	panic(err)
}
endsnippet

snippet - "docopt command declaration" "is_inside_docopt_section(snip, 'usage')" beA
`!p snip.rv = get_program_name_from_usage(snip)` -$0
endsnippet

post_jump "if snip.tabstop == 2: docopt_format_options(snip)"
snippet "\s*-" "docopt option declaration" "is_inside_docopt_section(snip, 'options')" beAr
  -$1`!p snip.rv=get_options_indentation(snip)``!p snip.rv=split_long_docopt_line(t, snip)`$2
endsnippet

snippet [ "docopt option default with matchem" "is_inside_docopt_section(snip, 'options')" eA
`!p snip.rv="["`default: $1
endsnippet

global !p
def fix_matchem(char):
    vim.eval('MatchemMatchDelete("{}")'.format(char))
    end = snip.snippet_end
    snip.buffer[end[0]] = str(snip.buffer[end[0]][:end[1]]) + str(snip.buffer[end[0]][end[1]+1:])
endglobal

post_expand "fix_matchem('[')"
snippet args[ "args[blah]" wA
args[`!p

if t[1].startswith('-'):
     if len(t[1]) > 2:
        snip.rv = '"-'
     else:
        snip.rv = '"'
else:
    snip.rv = '"<'

`$1`!p

if t[1].startswith('-'):
    snip.rv = '"'
else:
    snip.rv = '>"'

`].(${2:string})$0
endsnippet

# Snippet to call log.Debugf with function args.
# Should be expanded on line before actual function call.
# Function call should be formatted like following pattern:
#
#	 foo := bar(
#		arg1,
#		arg2,
#		arg3,
#	 )
#
# or like this pattern:
#
#	 bar(
#		arg1,
#		arg2,
#		arg3,
#	 )
#
snippet x "log.Debugf args of function on next line"
`!p
def is_next_line_contains_function_call_only(buffer, line):
	return re.match('.*\($', buffer[line + 1])

def get_function_name_from_line(buffer, line):
	matches = re.match('^(\t*|.*=\s)([\w\.]*)\($', buffer[line + 1])
	if matches:
		return matches.group(2)

def get_function_args_count(buffer, line, line_first_arg):
	while line <= len(buffer):
		line += 1
		matches = re.match(r'.*\)$', buffer[line])
		if matches:
			return line - line_first_arg

def run(buffer, line):
	if not is_next_line_contains_function_call_only(buffer, line):
		return

	function_name = get_function_name_from_line(buffer, line)
	line_current_arg = line + 2
	args_count = get_function_args_count(buffer, line, line_current_arg)
	if args_count == 0:
		return

	buffer.append(
		snip.mkline(
			formatLogInfoFunction % (
				os.path.basename(px.buffer.get().name),
				line_current_arg + args_count + 1,
				function_name
			),
		),
		line
	)

	line += 1
	line_current_arg += 1
	line_last_arg = line_current_arg + args_count

	while line_current_arg < line_last_arg:
		arg = buffer[line_current_arg].strip()[:-1] # [:-1] to remove ','

		buffer.append(
			snip.mkline(formatLogInfo % (arg.replace('"', r'\"'), arg)),
			line
		)

		line_current_arg += 2
		line += 1
		line_last_arg += 1

buffer = px.buffer.get()
line, _ = px.cursor.get()

formatLogInfo = 'log.Debugf("\\t%%s: %%#v", "%s", %s); '
formatLogInfoFunction = 'log.Debugf("%s:%s: %%s", "%s()"); '

run(buffer, line)
`
endsnippet
