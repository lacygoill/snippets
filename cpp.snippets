global !p
from snippets import *

import px
for full_name, name in px.libs().items():
    exec("import " + full_name)
endglobal

snippet n "function" w
${1:int} ${2:main}($3) {
	$4
}
endsnippet

snippet i "if" b
if ($1) {
	$2
}$0
endsnippet

snippet }e "else" wA
} else {
	$1
}
endsnippet

context "px.snippets.make_context(snip)"
snippet pr "fmt printf xxx debug" bw
`!p

try:
    once
except:
    once = True
    cursor = px.cursor.get()

func = 'fprintf'
left = '\\n"'
right = ')'

if t[1] != '':
    left = ' ' + t[1] + ': %s\\n", '
    right = ')'

if " " in t[1]:
    left = ' '
    right = '\\n")'

left = " " + os.path.basename(px.buffer.get().name) + ":" + str(cursor[0]) + left

``!p snip.rv = func + "(stderr, \"XXXXXX" + left`$1`!p snip.rv=right`;
endsnippet

snippet dp "" w
debugf("$1: ${3:%s}", $2);
endsnippet

snippet dp "debugf" w
debugf("$1: ${3:%s}", $2)
endsnippet

snippet fi "for" w
for ($1 = 0; $1 < $2; $1++) {
    $3
}
endsnippet

snippet f "for empty" w
for ($1) {
	$2
}

$0
endsnippet

snippet r "" w
return $0;
endsnippet

snippet # "#include" b
`!p
lparen = '<'
rparen = '>'
if os.path.exists(t[1]):
    lparen = '"'
    rparen = '"'
`#include `!p snip.rv = lparen`$1`!p snip.rv = rparen`
endsnippet

snippet #d "#define" wA
`!p
parts = t[1].split(' ')
parts[0] = parts[0].upper()
t[1] = ' '.join(parts)
`#define $1
endsnippet

snippet t "struct" b
struct $1 {
    $0
};
endsnippet

snippet s "std::" w
std::$0
endsnippet

priority 10
snippet std::s "std::string" w
std::string $0
endsnippet
